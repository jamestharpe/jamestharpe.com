{"componentChunkName":"component---src-templates-article-tsx","path":"/kubernetes/","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"date\": \"2021-08-18T11:13:14.000Z\",\n  \"description\": \"A system to conduct an orchestra of containers\",\n  \"tags\": [\"containers\", \"open-source-software\"],\n  \"title\": \"Kubernetes (k8s)\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Kubernetes (k8s)\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Kubernetes\"), \", sometimes stylistically written as \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"k8s\"), \", is an \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../open-source-software/\"\n  }, \"open-source software\"), \" system to automate the deployment, scaling, and management of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../containers/\"\n  }, \"containerized\"), \" applications. Kubernetes includes networking and storage abstractions to make it easy for deployments to be distributed across physical machine boundaries while maintaining the ability to communicate. Kubernetes provides the means to eliminate single points of failure, automatically scale, and to update containers without downtime through built-in services for service discovery, load balancing, automated roll-outs/roll-backs, self healing, and configuration management.\"), mdx(\"h2\", null, \"How Kubernetes Works\"), mdx(\"p\", null, \"Kubernetes works by maintaining a cluster of nodes, where each \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"node\"), \" is a physical or virtual machine capable of running one or more pods and managed by an agent called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet/\"\n  }, \"kublet\"), \". A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"pod\"), \" is a group of containers that share a common configuration and are scheduled onto the same node. Kubernetes is declaratively configured by a manifest file, which describes the desired state of the cluster. Differences between the desired state are reconciled through the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"control plane\"), \", which is an extensible set of components that are responsible for maintaining the desired state of the cluster.\"), mdx(\"div\", {\n    \"className\": \"mermaid\"\n  }, \"graph TD\\n    subgraph Cluster\\n\\t\\tMaster(\\\"fa:fa-asterisk Master Node\\\")\\n        subgraph Node1[Node]\\n            Kublet1(\\\"fa:fa-cog Kublet\\\") --> Pod1[Pod]\\n            Kublet1 --> Pod2[Pod]\\n            Pod1[Pod]\\n            Pod2[Pod]\\n        end\\n\\t\\tsubgraph Node2[Node]\\n            Kublet2(\\\"fa:fa-cog Kublet\\\") --> Pod3[Pod]\\n            Kublet2 --> Pod4\\n            Pod3[Pod]\\n            Pod4[Pod]\\n        end\\n        subgraph Node3[Node]\\n            Kublet3(\\\"fa:fa-cog Kublet\\\") --> Pod5[Pod]\\n            Kublet3 --> Pod6\\n            Pod5[Pod]\\n            Pod6[Pod]\\n        end\\n    end\\n    subgraph CP[Control Plane]\\n\\t\\tStore[(\\\"Store (etcd)\\\")] -->|Configuration| Master\\n        API --> Master\\n        Scheduler --> Master\\n        Controller[\\\"Controller Manager\\\"] --> Master\\n    end\\n    kubectl[\\\"$ kubectl\\\"] --> API\\n    Master --> Kublet1\\n    Master --> Kublet2\\n    Master --> Kublet3\"), mdx(\"h2\", null, \"Components of Kubernetes\"), mdx(\"h3\", null, \"Pods\"), mdx(\"p\", null, \"Pods are the most basic unit of execution in Kubernetes. A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"pod\"), \" is a group of containers that share a common configuration and are scheduled onto the same node. Pods are the smallest deployable unit of execution in Kubernetes.\"), mdx(\"h3\", null, \"ReplicaSets\"), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ReplicaSet\"), \" is a declarative way to maintain a set of pods that share a common configuration. Each pod in a ReplicaSet is a replica of all the other pods in that set, and the ReplicaSets creates and maintains the desired state of the pods. ReplicaSets act as a self-healing mechanism in that if a pod fails, the ReplicaSet will create a new pod to replace it. ReplicaSets provide fault tolerance and can also be used to automatically scale the number of pods horizontally based on a variety of conditions.\"), mdx(\"p\", null, \"ReplicaSets rely on pod templates to define the desired state of the pods.\"), mdx(\"h3\", null, \"Deployments\"), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"deployment\"), \" is a declarative way to manage ReplicaSets. Deployments support zero-downtime updates and rollbacks through the orchestrated creation and destruction of ReplicaSets.\"), mdx(\"h3\", null, \"Labels\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Labels\"), \" are key-value pairs attached to pods, ReplicaSets, Deployments, and other Kubernetes objects to organize and identify those objects. Common uses for labels include identifying application names (e.g. \\\"mysql\\\"), versions (e.g. \\\"5.7.21\\\"), and instances (e.g. \\\"mysql-production\\\"), architectural components (e.g. \\\"ui\\\" or \\\"database\\\"), higher-level applications (e.g. \\\"whenner\\\"), and other application meta information.\"), mdx(\"h3\", null, \"Services\"), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"service\"), \" allows an application to be exposed on a network, even as the pods that host the application are created and destroyed, by abstracting pod IP addresses away from application consumers and load balancing between active pods. Services rely on labels to to associate with pods.\"), mdx(\"div\", {\n    \"className\": \"mermaid\"\n  }, \"graph TD\\n\\tClient[External Client] --> Service\\n\\tsubgraph Kubernetes\\n\\t\\tService --> Pod1\\n\\t\\tService --> Pod2\\n\\t\\tend\"), mdx(\"p\", null, \"There are four main types of Service:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ClusterIP service\"), \" exposes the service on an IP address internal to the cluster so that only pods within the cluster can communicate with the service\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"NodePort service\"), \" exposes the service on static port on each node's IP address so that the service is accessible from outside the cluster, the node then uses a ClusterIP service to proxy requests on that port to an appropriate pod\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"LoadBalancer service\"), \" allocates an external IP address and integrates with an external load-balancer to automatically create routes to nodes (and pods by extension) exposed by a NodePort service\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"An \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"ExternalName service\"), \" associates a service with a DNS name by returning a CNAME record on DNS lookup\")), mdx(\"h3\", null, \"Storage and Volumes\"), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"volume\"), \" references a storage location that can be used by Kubernetes for persistent storage. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Volume mounts\"), \" attach pods to volumes via the volume name and a specified mount path.\"), mdx(\"p\", null, \"Basic types of volumes include:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"emptyDir\"), \" volumes provide an empty directory for the lifetime of a Pod. This is useful for sharing files between containers, caching, and other ephemeral storage needs.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"hostPath\"), \" volumes provide access to the underlying node's filesystem. This is useful for added node health monitoring, such as \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/google/cadvisor\"\n  }, \"cAdvisor\"), \". For security reasons, \", mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"hostPath\"), \" volumes are typically readonly.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"code\", {\n    parentName: \"li\",\n    \"className\": \"language-text\"\n  }, \"nfs\"), \" volumes provide network file system access. This is useful for shared resources across pods and pod life cycles.\")), mdx(\"h4\", null, mdx(\"code\", {\n    parentName: \"h4\",\n    \"className\": \"language-text\"\n  }, \"PersistentVolumes\")), mdx(\"p\", null, \"A \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"PersistentVolume\"), \" provides cluster-wide storage through network-attached storage (NAS) that can be made available to any pod even if it is rescheduled to another node. A PersistentVolume is associated with a pod through a \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"PersistentVolumeClaim (PVC)\"), \". The storage that backs a persistent volume is usually implemented as a Network File System (NFS), iSCSI, cloud service, or other type of network based storage.\"), mdx(\"h2\", null, \"Kubernetes Resources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://kubernetes.io/docs/home/\"\n  }, \"Official Kubernetes Documentation\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/kubernetes/examples\"\n  }, \"Open Source Kubernetes Examples\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://kubernetes.io/docs/tutorials/\"\n  }, \"Official Kubernetes Tutorials\"))));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"slug":"/kubernetes/"},"frontmatter":{"description":"A system to conduct an orchestra of containers","tags":["containers","open-source-software"],"title":"Kubernetes (k8s)"}}},"pageContext":{"slug":"/kubernetes/"}},"staticQueryHashes":["3772659826","3794076007","80858887"]}