{"componentChunkName":"component---src-templates-article-tsx","path":"/pub-sub/","result":{"data":{"mdx":{"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"date\": \"2021-11-28T13:34:25.000Z\",\n  \"description\": \"A software engineering design pattern to separate responsibility between commands and queries\",\n  \"tags\": [\"swe-design-patterns\", \"software-architecture\", \"distributed-systems\"],\n  \"title\": \"Publish/Subscribe Pattern (Pub-sub)\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Publish/subscribe pattern (pub-sub)\"), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"publish/subscribe pattern (pub-sub)\"), \" is a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../software-engineering/\"\n  }, \"software engineering\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../swe-design-patterns/\"\n  }, \"design pattern\"), \" used commonly in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../distributed-systems/\"\n  }, \"distributed systems\"), \" to communicate asynchronously and parallelize tasks across applications, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../data-pipelines/\"\n  }, \"data pipelines\"), \", and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../microservices/\"\n  }, \"services\"), \" in a decoupled way.\"), mdx(\"p\", null, \"Events are usually published by a single publisher and consumed by multiple subscribers. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Publishers\"), \" are systems of record applications that publish events while \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"subscribers\"), \" consume and process events. Publishers generally publishes events without regard to how or when subscribers will process them. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Events\"), \" are simply records of \\\"something that happened\\\" (e.g. \\\"customer added\\\", \\\"order placed\\\", and so on).\"), mdx(\"h2\", null, \"Designing event models\"), mdx(\"p\", null, \"For events to be useful, they must carry enough information for subscribers to process them successfully. Given that it's impractical, and maybe impossible, to foresee all the potential subscribers of an event, it's useful to take a methodical approach to event model design.\"), mdx(\"p\", null, \"One such approach is to use a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../transitive-closure/\"\n  }, mdx(\"strong\", {\n    parentName: \"a\"\n  }, \"transitive closure\")), \" which calculates the relationships that would need to be added between entities to directly (as opposed to indirectly) associate related data. For example, take the following relational schema used to book musical acts at various venues:\"), mdx(\"div\", {\n    \"className\": \"mermaid\"\n  }, \"erDiagram\\n\\tBANDS {\\n        int id\\n        string name\\n    }\\n\\tBAND-MEMBERS {\\n        int bandId\\n        int personId\\n    }\\n\\tPEOPLE {\\n        int id\\n        string name\\n    }\\n\\tSHOWS {\\n\\t\\tint bandId\\n\\t\\tint venueId\\n\\t\\tstring name\\n\\t\\tdate start\\n\\t\\tdate end\\n\\t}\\n\\tSHOW-CHECKLIST {\\n\\t\\tint id\\n\\t\\tint showId\\n\\t\\tstring toDo\\n\\t}\\n\\tVENUES {\\n\\t\\tint id\\n\\t\\tstring street\\n\\t\\tstring postalCode\\n\\t}\\n\\n\\tBANDS ||--o{ SHOWS : schedule\\n\\tBANDS ||--|{ BAND-MEMBERS : have\\n\\tBAND-MEMBERS }o--|| PEOPLE : are\\n\\tSHOWS }o--|| VENUES : have\\n\\tSHOWS }|--o{ SHOW-CHECKLIST: has\"), mdx(\"p\", null, \"To generate an \\\"show scheduled\\\" event, we need to determine what information a subscriber would need to know whenever an event is booked. We can calculate that by identifying all of the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"direct and indirect\"), \" relationships to the \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"SHOWS\"), \" entities and then demoralize them into the event structure.\"), mdx(\"p\", null, \"The first step is to follow the relationships \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"from\"), \" the \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"SHOWS\"), \" table. In this case, we see that a show is defined by the associate BAND and VENUE entities, thus some data from the \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"BANDS\"), \" and \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"VENUES\"), \" records are likely to be useful to consumers of the \\\"show scheduled\\\" event. However, to \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"BANDS\"), \" have \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"BAND-MEMBERS\"), \" which have \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"PEOPLE\"), \", thus it likely makes sense to include data from these entities as well.\"), mdx(\"p\", null, \"The second step is to follow the relationships \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"to\"), \" the \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"SHOWS\"), \" table. In this case, we see that each SHOW can have zero or more CHECKLIST items, thus some data from the \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"SHOW-CHECKLIST\"), \" is likely to be useful as well.\"), mdx(\"p\", null, \"Finally, with all the required information identified, we can design a reasonable schema for the \\\"show scheduled\\\" event:\"), mdx(\"div\", {\n    \"className\": \"mermaid\"\n  }, \"erDiagram\\n\\tSHOW_SCHEDULED_EVENT {\\n\\t\\tint showId\\n        string showName\\n\\t\\tdate startDate\\n\\t\\tdate endDate\\n\\t\\tstring bandName\\n\\t\\tlist peopleNames\\n\\t\\tstring venueName\\n\\t\\tlist toDos\\n    }\"), mdx(\"p\", null, \"Though this can seem excessive or a violation of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../yagni/\"\n  }, \"YAGNI\"), \" because this data can be looked up with only the \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"id\"), \" of the added \", mdx(\"code\", {\n    parentName: \"p\",\n    \"className\": \"language-text\"\n  }, \"SHOWS\"), \" entity, it's not. Such lookups can create excessive \\\"chatter\\\" that actually consumes more network, storage, and compute cycles than the larger payload would tend to save. There is also the risk that the underlying data changes between when the event was published and when it was processed, leaving subscribers with inaccurate data about the event \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"when it occurred\"), \".\"), mdx(\"p\", null, \"Finally, this level of de-normalization can reduce dependence on message order. If, for example, we relied on the \\\"venue created\\\" event to be processed \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"before\"), \" the \\\"show scheduled\\\" event, ensuring the messages are processed in sequence can add complexity and reduce scalability.\"), mdx(\"h2\", null, \"Subscriber patterns\"), mdx(\"h3\", null, \"Competing consumer pattern\"), mdx(\"p\", null, \"The \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"competing consumer pattern\"), \" organizes subscribers by type to simplify how services scale. When there are multiple types of subscribers, each events should be consumed by all types of subscriber. However, when there are multiple instances of a single type of subscriber then each event should only be consumed by a single subscriber instance.\"), mdx(\"p\", null, \"To manage this distinction, subscribers can be grouped into exchanges. An \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"exchange\"), \" is a message queue that serves a single type of subscriber. This allows the system to scale based on the workload (i.e. queue size) and avoid redundant event processing.\"), mdx(\"div\", {\n    \"className\": \"mermaid\"\n  }, \"flowchart TD\\n    Publisher -->|publish| Exchange((Exchange))\\n\\tExchange -->|push| Q1[(Queue 1)]\\n\\tExchange -->|push| Q2[(Queue 2)]\\n\\tExchange -->|push| Q3[(Queue 3)]\\n\\tQ1 -->|pull| Q1P[Q1 Subscriber Pool]\\n\\tQ2 -->|pull| Q2P[Q2 Subscriber Pool]\\n\\tQ3 -->|pull| Q3P[Q3 Subscriber Pool]\"), mdx(\"p\", null, \"Each subscriber in the subscriber pool pulls from the same queue, ensuring each message is only processed once.\"), mdx(\"h3\", null, \"Commutative message handling \"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Commutative message handling\"), \" is a desirable property of subscribers where the order in which messages are processed doesn't matter, similar to algebraic property (i.e. \", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"katex\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"katex-mathml\"\n  }, mdx(\"math\", {\n    parentName: \"span\",\n    \"xmlns\": \"http://www.w3.org/1998/Math/MathML\"\n  }, mdx(\"semantics\", {\n    parentName: \"math\"\n  }, mdx(\"mrow\", {\n    parentName: \"semantics\"\n  }, mdx(\"mi\", {\n    parentName: \"mrow\"\n  }, \"a\"), mdx(\"mo\", {\n    parentName: \"mrow\"\n  }, \"+\"), mdx(\"mi\", {\n    parentName: \"mrow\"\n  }, \"b\"), mdx(\"mo\", {\n    parentName: \"mrow\"\n  }, \"=\"), mdx(\"mi\", {\n    parentName: \"mrow\"\n  }, \"b\"), mdx(\"mo\", {\n    parentName: \"mrow\"\n  }, \"+\"), mdx(\"mi\", {\n    parentName: \"mrow\"\n  }, \"a\")), mdx(\"annotation\", {\n    parentName: \"semantics\",\n    \"encoding\": \"application/x-tex\"\n  }, \"a + b = b + a\")))), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"katex-html\",\n    \"aria-hidden\": \"true\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"base\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"strut\",\n    \"style\": {\n      \"height\": \"0.66666em\",\n      \"verticalAlign\": \"-0.08333em\"\n    }\n  }), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"mord mathnormal\"\n  }, \"a\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"mspace\",\n    \"style\": {\n      \"marginRight\": \"0.2222222222222222em\"\n    }\n  }), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"mbin\"\n  }, \"+\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"mspace\",\n    \"style\": {\n      \"marginRight\": \"0.2222222222222222em\"\n    }\n  })), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"base\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"strut\",\n    \"style\": {\n      \"height\": \"0.69444em\",\n      \"verticalAlign\": \"0em\"\n    }\n  }), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"mord mathnormal\"\n  }, \"b\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"mspace\",\n    \"style\": {\n      \"marginRight\": \"0.2777777777777778em\"\n    }\n  }), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"mrel\"\n  }, \"=\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"mspace\",\n    \"style\": {\n      \"marginRight\": \"0.2777777777777778em\"\n    }\n  })), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"base\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"strut\",\n    \"style\": {\n      \"height\": \"0.77777em\",\n      \"verticalAlign\": \"-0.08333em\"\n    }\n  }), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"mord mathnormal\"\n  }, \"b\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"mspace\",\n    \"style\": {\n      \"marginRight\": \"0.2222222222222222em\"\n    }\n  }), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"mbin\"\n  }, \"+\"), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"mspace\",\n    \"style\": {\n      \"marginRight\": \"0.2222222222222222em\"\n    }\n  })), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"base\"\n  }, mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"strut\",\n    \"style\": {\n      \"height\": \"0.43056em\",\n      \"verticalAlign\": \"0em\"\n    }\n  }), mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"mord mathnormal\"\n  }, \"a\"))))), \"). Though message queues typically deliver messages in the order they were received, message processing may error out and have to be retried as later messages are successfully processed, or a later message may simply get processed faster than an earlier message.\"), mdx(\"p\", null, \"Messages of the same type can be made commutative by attaching a timestamp to the event. For example, if an \\\"venue description changed\\\" event is processed out of order, it could cause the subscriber to revert its venue description to the older version. However, if the event includes a timestamp and the stored data is newer than the message timestamp, then the message can be safely discarded.\"), mdx(\"p\", null, \"Messages of different types can be made commutative by storing related information as it arrives. For example, if a show is scheduled for a venue and then the venue description is changed, we can't know for sure that the related messages will be processed in that order. Thus, if the \\\"venue description changed\\\" event is processed before the \\\"show scheduled\\\" event (even though it happened afterward), we could process stale venue when the \\\"show scheduled\\\" event is processed. To prevent this, the venue data should \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"also\"), \" be saved by the subscriber, along with the timestamp. Then when the \\\"show scheduled\\\" event is processed, the timestamp can be compared to the timestamps for related data and only \\\"new\\\" information processed.\"));\n}\n;\nMDXContent.isMDXComponent = true;","fields":{"slug":"/pub-sub/"},"frontmatter":{"description":"A software engineering design pattern to separate responsibility between commands and queries","tags":["swe-design-patterns","software-architecture","distributed-systems"],"title":"Publish/Subscribe Pattern (Pub-sub)"}}},"pageContext":{"slug":"/pub-sub/"}},"staticQueryHashes":["1957148337","3794076007","80858887"]}